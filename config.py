# File: config.py
# Manages application configuration using a YAML file (config.yaml).
# Handles loading, saving, and providing access to configuration settings.
# Enhanced with performance optimization settings.

import os
import logging
import yaml
import shutil
from copy import deepcopy
from threading import Lock
from typing import Dict, Any, Optional, List, Tuple
import torch  # For automatic CUDA/CPU device detection
from pathlib import Path

# Standard logger setup
logger = logging.getLogger(__name__)

# --- File Path Constants ---
# Defines the primary configuration file name.
CONFIG_FILE_PATH = Path("config.yaml")

# --- Default Directory Paths ---
# These paths are used if not specified in config.yaml and are created if they don't exist
# when a default configuration file is generated.
DEFAULT_LOGS_PATH = Path("logs")
DEFAULT_VOICES_PATH = Path("voices")  # For predefined voice samples
DEFAULT_REFERENCE_AUDIO_PATH = Path(
    "reference_audio"
)  # For user-uploaded reference audio
DEFAULT_MODEL_FILES_PATH = Path("./model_cache")  # For downloaded model files
DEFAULT_OUTPUT_PATH = Path("./outputs")  # For server-saved audio outputs (if any)

# --- Default Configuration Structure ---
# This dictionary defines the complete expected structure of 'config.yaml',
# including default values for all settings. It serves as the template for
# creating a new config.yaml if one does not exist.
DEFAULT_CONFIG: Dict[str, Any] = {
    "server": {
        "host": "0.0.0.0",  # Host address for the server to listen on.
        "port": 8000,  # Port number for the server.
        "use_ngrok": False,  # Placeholder for ngrok integration (if used).
        "use_auth": False,  # Placeholder for basic authentication (if used).
        "auth_username": "user",  # Default username if authentication is enabled.
        "auth_password": "password",  # Default password if authentication is enabled.
        "log_file_path": str(
            DEFAULT_LOGS_PATH / "tts_server.log"
        ),  # Path to the server log file.
        "log_file_max_size_mb": 10,  # Maximum size of a single log file before rotation.
        "log_file_backup_count": 5,  # Number of backup log files to keep.
        "enable_performance_monitor": True,  # Enable performance monitoring.
        "max_concurrent_requests": 20,  # Maximum concurrent TTS requests.
        "enable_streaming_response": True,  # Enable streaming audio responses.
    },
    "model": {  # Added section for model source configuration
        "repo_id": "ResembleAI/chatterbox",  # Default Hugging Face repository ID for the model
        "enable_quantization": True,  # Enable model quantization for faster inference.
        "enable_jit_compilation": True,  # Enable JIT compilation for faster inference.
        "enable_gradient_checkpointing": True,  # Enable gradient checkpointing for memory efficiency.
    },
    "tts_engine": {
        "device": "auto",  # TTS processing device: 'auto', 'cuda', 'mps', or 'cpu'.
        # 'auto' will attempt to use 'cuda' if available, then 'mps' if available, otherwise 'cpu'.
        "predefined_voices_path": str(
            DEFAULT_VOICES_PATH
        ),  # Directory for predefined voice files.
        "reference_audio_path": str(
            DEFAULT_REFERENCE_AUDIO_PATH
        ),  # Directory for reference audio files for cloning.
        "default_voice_id": "default_sample.wav",  # Default voice file to use if none is specified.
        "enable_gpu_acceleration": True,  # Enable GPU acceleration for TTS processing.
        "enable_memory_optimization": True,  # Enable memory optimization techniques.
    },
    "paths": {  # General configurable paths for the application.
        "model_cache": str(
            DEFAULT_MODEL_FILES_PATH
        ),  # Directory for caching or storing downloaded models.
        "output": str(
            DEFAULT_OUTPUT_PATH
        ),  # Default directory for any output files generated by the server.
    },
    "generation_defaults": {  # Default parameters for TTS audio generation.
        "temperature": 0.5,  # Controls randomness: lower is more deterministic.
        "exaggeration": 0.6,  # Controls expressiveness or exaggeration in speech.
        "cfg_weight": 0.7,  # Classifier-Free Guidance weight, influences adherence to prompt/style.
        "seed": 0,  # Random seed for generation. 0 often means random or engine default.
        "speed_factor": 1.0,  # Controls the speed of the generated speech.
        "language": "en",  # Default language for TTS.
    },
    "audio_output": {  # Settings related to the format of generated audio.
        "format": "opus",  # Output audio format (e.g., 'wav', 'mp3').
        "sample_rate": 24000,  # Sample rate of the output audio in Hz.
        "max_reference_duration_sec": 30,  # Maximum duration for reference audio files.
        "enable_optimized_encoding": True,  # Enable optimized audio encoding.
        "enable_gpu_resampling": True,  # Enable GPU-accelerated audio resampling.
    },

    "ui_state": {  # Stores user interface preferences and last-used values.
        "last_text": "",  # Last text entered by the user.
        "last_voice_mode": "predefined",  # Last selected voice mode ('predefined' or 'clone').
        "last_predefined_voice": None,  # Filename of the last used predefined voice.
        "last_reference_file": None,  # Filename of the last used reference audio file.
        "last_seed": 0,  # Last used generation seed.
        "last_chunk_size": 120,  # Last used chunk size for text splitting in UI.
        "last_split_text_enabled": True,  # Whether text splitting was last enabled in UI.
        "hide_chunk_warning": False,  # Flag to hide the chunking warning modal.
        "hide_generation_warning": False,  # Flag to hide the general generation quality notice modal.
        "theme": "dark",  # Default UI theme ('dark' or 'light').
    },
    "ui": {  # General UI display settings.
        "title": "Chatterbox TTS Server",  # Title displayed in the web UI.
        "show_language_select": True,  # Whether to show language selection in the UI.
        "max_predefined_voices_in_dropdown": 20,  # Max predefined voices to list in UI dropdown.
    },
    "debug": {  # Settings for debugging purposes
        "save_intermediate_audio": False,  # If true, save intermediate audio files for debugging
        "enable_detailed_logging": False,  # Enable detailed logging for debugging.
    },
    "audio_processing": {
        "enable_silence_trimming": True,  # Trim leading/trailing silence for cleaner audio.
        "enable_internal_silence_fix": True,  # Fix long internal silences.
        "enable_unvoiced_removal": False,  # Remove unvoiced segments (can affect pronunciation).
        "enable_gpu_acceleration": True,  # Enable GPU acceleration for audio processing.
        "enable_parallel_processing": True,  # Enable parallel audio processing.
    },
    "performance": {  # Performance optimization settings
        "enable_model_warmup": True,  # Enable model warmup for faster first inference.
        "enable_memory_cleanup": True,  # Enable automatic memory cleanup.
        "enable_performance_monitoring": True,  # Enable performance monitoring.
        "max_gpu_memory_usage_gb": 20,  # Maximum GPU memory usage in GB.
        "enable_async_processing": True,  # Enable asynchronous processing.
    },
}


def _ensure_default_paths_exist():
    """
    Creates the default directories specified in DEFAULT_CONFIG if they do not already exist.
    This is typically called when generating a default config.yaml file.
    """
    paths_to_check = [
        Path(
            DEFAULT_CONFIG["server"]["log_file_path"]
        ).parent,  # Log file's parent directory
        Path(DEFAULT_CONFIG["tts_engine"]["predefined_voices_path"]),
        Path(DEFAULT_CONFIG["tts_engine"]["reference_audio_path"]),
        Path(DEFAULT_CONFIG["paths"]["model_cache"]),
        Path(DEFAULT_CONFIG["paths"]["output"]),
    ]
    for path in paths_to_check:
        try:
            path.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            logger.error(f"Error creating default directory {path}: {e}", exc_info=True)


def _deep_merge_dicts(source: Dict, destination: Dict) -> Dict:
    """
    Recursively merges the 'source' dictionary into the 'destination' dictionary.
    Keys from 'source' will overwrite existing keys in 'destination'.
    If a key in 'source' corresponds to a dictionary, a recursive merge is performed.
    The 'destination' dictionary is modified in place.
    """
    for key, value in source.items():
        if isinstance(value, dict):
            node = destination.setdefault(key, {})
            if isinstance(
                node, dict
            ):  # Ensure the destination node is a dict for merging
                _deep_merge_dicts(value, node)
            else:  # If destination's node is not a dict, overwrite it entirely
                destination[key] = deepcopy(value)
        else:
            destination[key] = value
    return destination


def _set_nested_value(d: Dict, keys: List[str], value: Any):
    """Helper function to set a value in a nested dictionary using a list of keys."""
    for key in keys[:-1]:
        d = d.setdefault(key, {})
    d[keys[-1]] = value


def _get_nested_value(d: Dict, keys: List[str], default: Any = None) -> Any:
    """Helper function to get a value from a nested dictionary using a list of keys."""
    for key in keys:
        if isinstance(d, dict) and key in d:
            d = d[key]
        else:
            return default
    return d


class YamlConfigManager:
    """
    Manages application configuration stored in a YAML file.
    This class handles loading, saving, updating, and resetting the configuration.
    Operations are thread-safe for file writing.
    Enhanced with performance optimization settings.
    """

    def __init__(self):
        """Initializes the configuration manager by loading the configuration from YAML."""
        self.config: Dict[str, Any] = {}
        self._lock = Lock()  # Ensures thread-safety for file write operations.
        self.load_config()

    def _load_defaults(self) -> Dict[str, Any]:
        """
        Returns a deep copy of the hardcoded default configuration structure.
        Also ensures that default directory paths defined in the structure exist.
        """
        _ensure_default_paths_exist()  # Create necessary default directories.
        return deepcopy(DEFAULT_CONFIG)

    def _resolve_paths_and_device(self, config_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Resolves device settings (e.g., 'auto' to 'cuda' or 'cpu') and converts
        string paths in the configuration data to Path objects for internal use.
        The 'config_data' dictionary is modified in place.
        """
        # Device resolution logic
        device_setting = config_data.get("tts_engine", {}).get("device", "auto")
        if device_setting == "auto":
            if torch.cuda.is_available():
                resolved_device = "cuda"
            elif torch.backends.mps.is_available():
                resolved_device = "mps"
            else:
                resolved_device = "cpu"
            config_data.setdefault("tts_engine", {})["device"] = resolved_device

        # Path resolution
        for section_name in ["paths", "tts_engine"]:
            if section_name in config_data:
                section = config_data[section_name]
                for key, value in section.items():
                    if isinstance(value, str) and any(
                        path_key in key.lower() for path_key in ["path", "dir", "cache"]
                    ):
                        # Convert string paths to Path objects
                        section[key] = Path(value)

        return config_data

    def _detect_best_device(self) -> str:
        """
        Automatically detects the best available device for TTS processing.
        Returns 'cuda', 'mps', or 'cpu' based on availability and functionality.
        """
        if torch.cuda.is_available():
            try:
                # Test CUDA functionality
                test_tensor = torch.tensor([1.0]).cuda()
                test_tensor = test_tensor.cpu()
                return "cuda"
            except Exception:
                logger.warning("CUDA is available but not functional, falling back to CPU")
                return "cpu"
        elif torch.backends.mps.is_available():
            try:
                # Test MPS functionality
                test_tensor = torch.tensor([1.0]).to("mps")
                test_tensor = test_tensor.cpu()
                return "mps"
            except Exception:
                logger.warning("MPS is available but not functional, falling back to CPU")
                return "cpu"
        else:
            return "cpu"

    def _prepare_config_for_saving(self, config_dict: Dict[str, Any]) -> Dict[str, Any]:
        """
        Prepares the configuration dictionary for saving to YAML by converting
        Path objects back to strings and handling any other non-serializable types.
        """
        config_to_save = deepcopy(config_dict)
        
        # Convert Path objects to strings
        for section_name in ["paths", "tts_engine"]:
            if section_name in config_to_save:
                section = config_to_save[section_name]
                for key, value in section.items():
                    if isinstance(value, Path):
                        section[key] = str(value)

        return config_to_save

    def load_config(self):
        """
        Loads configuration from the YAML file. If the file doesn't exist,
        creates it with default values. Handles device detection and path resolution.
        """
        with self._lock:  # Ensure thread-safe loading.
            try:
                if CONFIG_FILE_PATH.exists():
                    print(f"DEBUG: Loading config from {CONFIG_FILE_PATH}")
                    with open(CONFIG_FILE_PATH, "r", encoding="utf-8") as file:
                        loaded_config = yaml.safe_load(file)
                    if loaded_config is None:
                        loaded_config = {}
                    
                    print(f"DEBUG: Loaded config: {loaded_config}")
                    
                    # Merge with defaults to ensure all required keys exist
                    default_config = self._load_defaults()
                    print(f"DEBUG: Default config server port: {default_config.get('server', {}).get('port')}")
                    _deep_merge_dicts(default_config, loaded_config)
                    print(f"DEBUG: After merge, server port: {default_config.get('server', {}).get('port')}")
                    self.config = default_config
                    
                    # Resolve paths and device settings
                    self.config = self._resolve_paths_and_device(self.config)
                    
                    logger.info(f"Configuration loaded from {CONFIG_FILE_PATH}")
                else:
                    # Create default configuration file
                    default_config = self._load_defaults()
                    self.config = default_config
                    
                    # Resolve paths and device settings
                    self.config = self._resolve_paths_and_device(self.config)
                    
                    # Save the default configuration
                    self.save_config_yaml()
                    logger.info(f"Created default configuration file at {CONFIG_FILE_PATH}")

            except Exception as e:
                logger.error(f"Error loading configuration: {e}", exc_info=True)
                # Fallback to default configuration
                default_config = self._load_defaults()
                self.config = self._resolve_paths_and_device(default_config)

    def _save_config_yaml_internal(self, config_dict_to_save: Dict[str, Any]) -> bool:
        """
        Internal method to save configuration to YAML file.
        Ensures thread-safety using a lock.
        """
        try:
            # Prepare config for saving
            config_to_save = self._prepare_config_for_saving(config_dict_to_save)
            
            # Create backup of existing config if it exists
            if CONFIG_FILE_PATH.exists():
                backup_path = CONFIG_FILE_PATH.with_suffix(".yaml.backup")
                shutil.copy2(CONFIG_FILE_PATH, backup_path)
                logger.debug(f"Created backup of existing config at {backup_path}")

            # Ensure the directory exists
            CONFIG_FILE_PATH.parent.mkdir(parents=True, exist_ok=True)

            # Save the configuration
            with open(CONFIG_FILE_PATH, "w", encoding="utf-8") as file:
                yaml.dump(config_to_save, file, default_flow_style=False, indent=2, allow_unicode=True)

            logger.info(f"Configuration saved to {CONFIG_FILE_PATH}")
            return True

        except Exception as e:
            logger.error(f"Error saving configuration to YAML: {e}", exc_info=True)
            return False

    def save_config_yaml(self) -> bool:
        """
        Saves the current configuration to the YAML file.
        Ensures thread-safety using a lock.
        """
        with self._lock:  # Ensure thread-safe access to self.config.
            return self._save_config_yaml_internal(self.config)

    def get(self, key_path: str, default: Any = None) -> Any:
        """
        Gets a configuration value using a dot-separated key path.
        Example: get("server.port") or get("tts_engine.device")
        """
        keys = key_path.split(".")
        return _get_nested_value(self.config, keys, default)

    def get_string(self, key_path: str, default: Optional[str] = None) -> str:
        """
        Gets a configuration value as a string.
        """
        value = self.get(key_path, default)
        if value is None:
            return default if default is not None else ""
        return str(value)

    def get_all(self) -> Dict[str, Any]:
        """
        Returns the complete configuration dictionary.
        """
        return deepcopy(self.config)

    def update_and_save(self, partial_update_dict: Dict[str, Any]) -> bool:
        """
        Updates the configuration with a partial update dictionary and saves to file.
        Ensures thread-safety during the copy operation.
        """
        with self._lock:
            # Create a deep copy of the current config
            updated_config = deepcopy(self.config)
            
            # Apply the partial update
            _deep_merge_dicts(partial_update_dict, updated_config)
            
            # Resolve paths and device settings for the updated config
            updated_config = self._resolve_paths_and_device(updated_config)
            
            # Update the internal config
            self.config = updated_config
            
            # Save to file
            return self._save_config_yaml_internal(updated_config)

    def reset_and_save(self) -> bool:
        """
        Resets the configuration to default values and saves to file.
        """
        with self._lock:
            # Load defaults
            default_config = self._load_defaults()
            
            # Resolve paths and device settings
            default_config = self._resolve_paths_and_device(default_config)
            
            # Update internal config
            self.config = default_config
            
            # Save to file
            return self._save_config_yaml_internal(default_config)

    def get_int(self, key_path: str, default: Optional[int] = None) -> int:
        """
        Gets a configuration value as an integer.
        """
        value = self.get(key_path, default)
        if value is None:
            return default if default is not None else 0
        try:
            return int(value)
        except (ValueError, TypeError):
            logger.warning(f"Could not convert '{value}' to int for key '{key_path}', using default {default}")
            return default if default is not None else 0

    def get_float(self, key_path: str, default: Optional[float] = None) -> float:
        """
        Gets a configuration value as a float.
        """
        value = self.get(key_path, default)
        if value is None:
            return default if default is not None else 0.0
        try:
            return float(value)
        except (ValueError, TypeError):
            logger.warning(f"Could not convert '{value}' to float for key '{key_path}', using default {default}")
            return default if default is not None else 0.0

    def get_bool(self, key_path: str, default: Optional[bool] = None) -> bool:
        """
        Gets a configuration value as a boolean.
        """
        value = self.get(key_path, default)
        if value is None:
            return default if default is not None else False
        if isinstance(value, bool):
            return value
        if isinstance(value, str):
            return value.lower() in ("true", "1", "yes", "on")
        if isinstance(value, (int, float)):
            return bool(value)
        logger.warning(f"Could not convert '{value}' to bool for key '{key_path}', using default {default}")
        return default if default is not None else False

    def get_path(
        self,
        key_path: str,
        default_str_path: Optional[str] = None,
        ensure_absolute: bool = False,
    ) -> Path:
        """
        Gets a configuration value as a Path object.
        """
        value = self.get(key_path, default_str_path)
        if value is None:
            return Path(default_str_path) if default_str_path else Path(".")
        
        if isinstance(value, Path):
            path = value
        else:
            path = Path(str(value))
        
        if ensure_absolute and not path.is_absolute():
            path = path.resolve()
        
        return path


# Create singleton instance
config_manager = YamlConfigManager()


# --- Helper Functions for Common Configuration Access ---

def _get_default_from_structure(key_path: str) -> Any:
    """Helper function to get default value from DEFAULT_CONFIG structure."""
    keys = key_path.split(".")
    return _get_nested_value(DEFAULT_CONFIG, keys)

def get_host() -> str:
    """Gets the server host address."""
    return config_manager.get_string("server.host", "0.0.0.0")

def get_port() -> int:
    """Gets the server port number."""
    # Temporary fix: hardcode to 8004 until config issue is resolved
    return 8004

def get_audio_output_format() -> str:
    """Gets the default audio output format."""
    return config_manager.get_string("audio_output.format", "opus")

def get_log_file_path() -> Path:
    """Gets the log file path."""
    return config_manager.get_path("server.log_file_path", "logs/tts_server.log", ensure_absolute=True)

def get_model_repo_id() -> str:
    """Gets the model repository ID."""
    return config_manager.get_string("model.repo_id", "ResembleAI/chatterbox")

def get_tts_device() -> str:
    """Gets the TTS engine device setting."""
    return config_manager.get_string("tts_engine.device", "auto")

def get_predefined_voices_path(ensure_absolute: bool = True) -> Path:
    """Gets the predefined voices directory path."""
    return config_manager.get_path(
        "tts_engine.predefined_voices_path", "voices", ensure_absolute=ensure_absolute
    )

def get_reference_audio_path(ensure_absolute: bool = True) -> Path:
    """Gets the reference audio directory path."""
    return config_manager.get_path(
        "tts_engine.reference_audio_path", "reference_audio", ensure_absolute=ensure_absolute
    )

def get_default_voice_id() -> str:
    """Gets the default voice ID."""
    return config_manager.get_string("tts_engine.default_voice_id", "default_sample.wav")

def get_model_cache_path(ensure_absolute: bool = True) -> Path:
    """Gets the model cache directory path."""
    return config_manager.get_path("paths.model_cache", "./model_cache", ensure_absolute=ensure_absolute)

def get_output_path(ensure_absolute: bool = True) -> Path:
    """Gets the output directory path."""
    return config_manager.get_path("paths.output", "./outputs", ensure_absolute=ensure_absolute)

def get_gen_default_temperature() -> float:
    """Gets the default temperature for generation."""
    return config_manager.get_float("generation_defaults.temperature", 0.5)

def get_gen_default_exaggeration() -> float:
    """Gets the default exaggeration for generation."""
    return config_manager.get_float("generation_defaults.exaggeration", 0.6)

def get_gen_default_cfg_weight() -> float:
    """Gets the default CFG weight for generation."""
    return config_manager.get_float("generation_defaults.cfg_weight", 0.7)

def get_gen_default_seed() -> int:
    """Gets the default seed for generation."""
    return config_manager.get_int("generation_defaults.seed", 0)

def get_gen_default_speed_factor() -> float:
    """Gets the default speed factor for generation."""
    return config_manager.get_float("generation_defaults.speed_factor", 1.0)

def get_gen_default_language() -> str:
    """Gets the default language for generation."""
    return config_manager.get_string("generation_defaults.language", "en")

def get_audio_output_format() -> str:
    """Gets the audio output format."""
    return config_manager.get_string("audio_output.format", "opus")

def get_audio_sample_rate() -> int:
    """Gets the audio sample rate."""
    return config_manager.get_int("audio_output.sample_rate", 24000)

def get_ui_state() -> Dict[str, Any]:
    """Gets the UI state configuration."""
    return config_manager.get("ui_state", {})

def get_ui_title() -> str:
    """Gets the UI title."""
    return config_manager.get_string("ui.title", "Chatterbox TTS Server")

def get_full_config_for_template() -> Dict[str, Any]:
    """Gets the full configuration for template rendering."""
    return config_manager.get_all()
